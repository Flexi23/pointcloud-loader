<html>
<head>
	<title>Fairy Dust | WebGL GPU particle experiment</title>
	<script type="text/javascript">
		var loadWorker;
		if (typeof (Worker) !== "undefined") {
			loadWorker = new Worker("js/async-load.js");
		} else {
			console.log("Web Worker not available");
		}
		var files = [];
		var fileIDs = [];
		function createFileID(file){
				return file.name + '.' + file.size;
		}
		function gotFile(file){
			return fileIDs.indexOf(createFileID(file)) > -1;
		}
		function addFile(file){
			var fileID = createFileID(file);
			files[fileID] = file;
			fileIDs.push(fileID);			
		}	
		function handleFileSelect(evt) {
			file = evt.target.files[0];
			if (file != null) {
				if(gotFile(file)){
					return "file has already been loaded";
				}
				document.getElementById("fileinfo").innerHTML = "... loading file content ...<br/>";
				if (loadWorker) {
					loadWorker.postMessage({file: file, bufferLength: 512*512});
					loadWorker.onmessage = function (e) {
						document.getElementById("fileinfo").innerHTML = e.data.statshtml;
						if (onlocationinfo && e.data.stridedArrayBuffers) {
							onlocationinfo(e.data);
						}
					}
					return "parsing async";
				}

				var arrayBuffers = [];
				var float32Arrays = [];
				var titles = [];
				var reader = new FileReader();
				reader.onload = function (progressEvent) {
					var before = Date.now();
					var lines = this.result.split('\n');
					var endsWithNewLine = (lines[lines.length - 1] != "");
					var numLines = lines.length - (endsWithNewLine ? 2 : 1);
					var bufferLength = e.data.bufferLength ? e.data.bufferLength : (2048 * 1024); // defaulting to 2M
					var numChunks = Math.ceil(numLines/bufferLength);
					var statshtml = numLines + " samples loaded<br />";
					titles = lines[0].split('\t');
					var min = []; max = []; avg = [];
					for(var title = 0; title < titles.length; title++){
						min[title] = Number.POSITIVE_INFINITY;
						max[title] = Number.NEGATIVE_INFINITY;
						avg[title] = 0;
						arrayBuffers[title] = new ArrayBuffer(numLines*4);
						float32Arrays[title] = new Float32Array(arrayBuffers[title]);
					}
					var progress = 0;
					for (var line = 1; line < numLines; line++) {
						var newProgress = Math.floor(100 * line / (lines.length+1));
						if(newProgress != progress){
							progress = newProgress;
							postMessage({statshtml: "parsing " + progress + "%<br/>"});
						}
						val = lines[line].split('\t');
						for(var title = 0; title < titles.length; title++){
							var v = Number(val[title]);
							if(min[title] > v){
								min[title] = v;
							}
							if(max[title] < v){
								max[title] = v;
							}
							if(avg[title] == undefined){
								avg[title] = 0;
							}
							avg[title] += v /(lines.length-1);
							float32Arrays[title][line-1] = v;
						}
					}
					var escapedTitles = [];
					for(var title = 0; title < titles.length; title++){
						var escapedTitle = titles[title].replace(/"/g,'');
						escapedTitles.push(escapedTitle);
						statshtml += escapedTitle + ": "
							+ min[title] + " - " + max[title] + " ("
							+ Math.round(avg[title]*10)/10 + ") <br/>";
					}
					statshtml += "parsing time [ms]: " + (Date.now() - before) + "<br/>";
					postMessage({
							statshtml: statshtml,
						});

					before = Date.now();
					var strideTitles = e.data.strideTitles ? e.data.strideTitles : [1,2,3,4];
					var stridedArrayBuffers = [];
					var stridedFloat32Arrays = [];
					for(var chunkIndex = 0; chunkIndex < numChunks; chunkIndex++){
						stridedArrayBuffers[chunkIndex] = new ArrayBuffer(bufferLength * 16); // 4x4 for four float32 values of four bytes for the values for the given stride indices
						stridedFloat32Arrays[chunkIndex]  = new Float32Array(stridedArrayBuffers[chunkIndex]);
					}
					var maxScale = Math.max(
							(max[strideTitles[0]]-min[strideTitles[0]]),
							(max[strideTitles[1]]-min[strideTitles[1]]),
							(max[strideTitles[2]]-min[strideTitles[2]])
						);

					progress = -1;
					for (var line = 0; line < numLines; line++) {
						var newProgress = Math.floor(100 * line / (lines.length+1));
						if(newProgress != progress){
							progress = newProgress;
							postMessage({statshtml: statshtml + "normalize into strided array chunks: " + progress + "%<br/>"});
						}
						var chunkIndex = Math.floor(line/bufferLength);
						var chunkLine = line - chunkIndex * bufferLength;
						var stridedFloat32Array = stridedFloat32Arrays[chunkIndex];
						stridedFloat32Array[chunkLine*4 + 0] = (float32Arrays[strideTitles[0]][line]-avg[strideTitles[0]])/maxScale;
						stridedFloat32Array[chunkLine*4 + 1] = (float32Arrays[strideTitles[1]][line]-avg[strideTitles[1]])/maxScale;
						stridedFloat32Array[chunkLine*4 + 2] = (float32Arrays[strideTitles[2]][line]-avg[strideTitles[2]])/maxScale;
						stridedFloat32Array[chunkLine*4 + 3] = (float32Arrays[strideTitles[3]][line]-avg[strideTitles[3]])/maxScale;
					}
					statshtml += "normalize into strided array chunks [ms]: "+ (Date.now() - before) + "<br/>";
					postMessage({
							statshtml: statshtml,
							stats: {min: min, max: max, avg: avg},
							titles: escapedTitles,
							numLines: numLines,
							numChunks: numChunks,
							arrayBuffers: arrayBuffers,
							bufferLength: bufferLength,
							stridedArrayBuffers: stridedArrayBuffers
						}, arrayBuffers.concat(stridedArrayBuffers));
				};
				reader.readAsText(file);
			};
		}
	</script>
	<script id="shader-vs" type="x-shader/x-vertex"> 
	attribute vec3 aPos;
	attribute vec2 aTexCoord;
	varying   vec2 uv;
varying vec2 uv_orig;
void main(void) {
	 gl_Position = vec4(aPos, 1.);
	 uv = aTexCoord;
	 uv_orig = uv;
}
	</script>

	<script id="shader-fs-inc" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif
varying vec2 uv_orig;

bool is_onscreen(vec2 uv){
	return (uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.);
}

float border(vec2 uv, float border, vec2 texSize){
	uv*=texSize;
	return (uv.x<border || uv.x>texSize.x-border || uv.y<border || uv.y >texSize.y-border) ? 1.:.0;
}

#define pi 3.141592653589793238462643383279
#define pi_inv 0.318309886183790671537767526745
#define pi2_inv 0.159154943091895335768883763372

float border(vec2 domain, float thickness){
	 vec2 uv = fract(domain-vec2(0.5));
	 uv = min(uv,1.-uv)*2.;
	 return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);
}

float square_mask(vec2 domain){
	return (domain.x <= 1. && domain.x >= 0. && domain.y <= 1. && domain.y >= 0.) ? 1. : 0.; 
}

vec2 complex_mul(vec2 factorA, vec2 factorB){
	 return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);
}

vec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){
	vec2 uv = domain - center;
	float d = length(uv);
	return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;
}

vec2 complex_div(vec2 numerator, vec2 denominator){
	 return vec2( numerator.x*denominator.x + numerator.y*denominator.y,
								numerator.y*denominator.x - numerator.x*denominator.y)/
					vec2(denominator.x*denominator.x + denominator.y*denominator.y);
}

// HSL to RGB converter code from http://www.gamedev.net/topic/465948-hsl-shader-glsl-code/
float Hue_2_RGB(float v1, float v2, float vH )
{
	float ret;
	 if ( vH < 0.0 )
		 vH += 1.0;
	 if ( vH > 1.0 )
		 vH -= 1.0;
	 if ( ( 6.0 * vH ) < 1.0 )
		 ret = ( v1 + ( v2 - v1 ) * 6.0 * vH );
	 else if ( ( 2.0 * vH ) < 1.0 )
		 ret = ( v2 );
	 else if ( ( 3.0 * vH ) < 2.0 )
		 ret = ( v1 + ( v2 - v1 ) * ( ( 2.0 / 3.0 ) - vH ) * 6.0 );
	 else
		 ret = v1;
	 return ret;
}

vec3 hsl2rgb(float H, float S, float L){
	float var_2, var_1, R, G, B;	
	if (S == 0.0)
	{
		 R = L;
		 G = L;
		 B = L;
	}
	else
	{
		 if ( L < 0.5 )
		 {
			 var_2 = L * ( 1.0 + S );
		 }
		 else
		 {
			 var_2 = ( L + S ) - ( S * L );
		 }

		 var_1 = 2.0 * L - var_2;

		 R = Hue_2_RGB( var_1, var_2, H + ( 1.0 / 3.0 ) );
		 G = Hue_2_RGB( var_1, var_2, H );
		 B = Hue_2_RGB( var_1, var_2, H - ( 1.0 / 3.0 ) );
	}
	return vec3(R,G,B);
}

	</script>

	<script id="shader-fs-copy" type="x-shader/x-fragment"> 
uniform sampler2D source;
varying vec2 uv;
void main(void) {
	gl_FragColor = texture2D(source, uv);
}
	</script>

	<script id="shader-fs-advance" type="x-shader/x-fragment"> 
varying vec2 uv;
uniform sampler2D sampler_prev;
uniform sampler2D sampler_prev_n;
uniform sampler2D sampler_blur;
uniform sampler2D sampler_blur2;
uniform sampler2D sampler_blur3;
uniform sampler2D sampler_blur4;
uniform sampler2D sampler_blur5;
uniform sampler2D sampler_blur6;
uniform sampler2D sampler_noise;
uniform sampler2D sampler_noise_n;
uniform sampler2D sampler_particles;

uniform vec4 rnd;
uniform vec4 rainbow;
uniform vec2 pixelSize;
uniform vec2 aspect;
uniform vec2 mouse;
uniform vec2 mouseV;
uniform float fps;
uniform float time;

void main(void) {
//	gl_FragColor.rgb = hsl2rgb(length((uv-mouse)*aspect)*2.,1., 0.5);
	gl_FragColor.rgb = texture2D(sampler_prev, uv).rgb;
	gl_FragColor.rgb += (texture2D(sampler_blur, uv).rgb -texture2D(sampler_blur2, uv).rgb)*0.1 - 0.001;
	gl_FragColor.rgb = clamp(gl_FragColor.rgb, 0.,1.);
	gl_FragColor.a = 1.;
}
	</script>

	<script id="shader-fs-composite" type="x-shader/x-fragment"> 
varying vec2 uv;
uniform sampler2D sampler_prev;
uniform sampler2D sampler_prev_n;
uniform sampler2D sampler_blur;
uniform sampler2D sampler_blur2;
uniform sampler2D sampler_blur3;
uniform sampler2D sampler_blur4;
uniform sampler2D sampler_blur5;
uniform sampler2D sampler_blur6;
uniform sampler2D sampler_noise;
uniform sampler2D sampler_noise_n;
uniform sampler2D sampler_particles;
uniform vec4 rnd;
uniform vec4 rainbow;
uniform vec2 pixelSize;
uniform vec2 aspect;
uniform vec2 mouse;
uniform vec2 mouseV;
uniform float fps;
uniform float time;
uniform float frame;

void main(void) {

	gl_FragColor = vec4(0.);
	gl_FragColor = texture2D(sampler_particles, uv_orig.yx)+0.5; // particle position texture

	gl_FragColor = texture2D(sampler_blur, uv_orig); //bypass

//	gl_FragColor.rgb = hsl2rgb(length((uv-mouse)*aspect)*2.,1., 0.5);

//	gl_FragColor = mix(gl_FragColor, vec4(1.), texture2D(sampler_prev, uv_orig));

//	gl_FragColor = mix(gl_FragColor, vec4(1.), texture2D(sampler_noise, uv + rnd.xy)*0.15);

	gl_FragColor.a = 1.;
}
	</script>

	<script id="shader-fs-blur-horizontal" type="x-shader/x-fragment">
// original shader from http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
// horizontal blur fragment shader
varying vec2 uv;
uniform sampler2D src_tex;
uniform vec2 pixelSize;

void main(void) // fragment
{
	float h = pixelSize.x;
	vec4 sum = vec4(0.0);
	sum += texture2D(src_tex, vec2(uv.x - 4.0*h, uv.y) ) * 0.05;
	sum += texture2D(src_tex, vec2(uv.x - 3.0*h, uv.y) ) * 0.09;
	sum += texture2D(src_tex, vec2(uv.x - 2.0*h, uv.y) ) * 0.12;
	sum += texture2D(src_tex, vec2(uv.x - 1.0*h, uv.y) ) * 0.15;
	sum += texture2D(src_tex, vec2(uv.x + 0.0*h, uv.y) ) * 0.16;
	sum += texture2D(src_tex, vec2(uv.x + 1.0*h, uv.y) ) * 0.15;
	sum += texture2D(src_tex, vec2(uv.x + 2.0*h, uv.y) ) * 0.12;
	sum += texture2D(src_tex, vec2(uv.x + 3.0*h, uv.y) ) * 0.09;
	sum += texture2D(src_tex, vec2(uv.x + 4.0*h, uv.y) ) * 0.05;
		gl_FragColor.xyz = sum.xyz/0.98; // normalize
	gl_FragColor.a = 1.;
} 
	</script>

	<script id="shader-fs-blur-vertical" type="x-shader/x-fragment">
varying vec2 uv;
uniform sampler2D src_tex;
uniform vec2 pixelSize;

void main(void) // fragment
{
	float v = pixelSize.y;
	vec4 sum = vec4(0.0);
	sum += texture2D(src_tex, vec2(uv.x, - 4.0*v + uv.y) ) * 0.05;
	sum += texture2D(src_tex, vec2(uv.x, - 3.0*v + uv.y) ) * 0.09;
	sum += texture2D(src_tex, vec2(uv.x, - 2.0*v + uv.y) ) * 0.12;
	sum += texture2D(src_tex, vec2(uv.x, - 1.0*v + uv.y) ) * 0.15;
	sum += texture2D(src_tex, vec2(uv.x, + 0.0*v + uv.y) ) * 0.16;
	sum += texture2D(src_tex, vec2(uv.x, + 1.0*v + uv.y) ) * 0.15;
	sum += texture2D(src_tex, vec2(uv.x, + 2.0*v + uv.y) ) * 0.12;
	sum += texture2D(src_tex, vec2(uv.x, + 3.0*v + uv.y) ) * 0.09;
	sum += texture2D(src_tex, vec2(uv.x, + 4.0*v + uv.y) ) * 0.05;
	gl_FragColor.xyz = sum.xyz/0.98;
	gl_FragColor.a = 1.;
}
	</script>

	<script type="x-shader/x-vertex" id="shader-particle-renderer-vs"> 
attribute vec2 uv; // see the difference to the other shader programs here? the uv isn't varying but an attr

uniform sampler2D sampler_prev;
uniform sampler2D sampler_prev_n;
uniform sampler2D sampler_blur;
uniform sampler2D sampler_blur2;
uniform sampler2D sampler_blur3;
uniform sampler2D sampler_blur4;
uniform sampler2D sampler_blur5;
uniform sampler2D sampler_blur6;
uniform sampler2D sampler_noise;
uniform sampler2D sampler_noise_n;
uniform sampler2D sampler_particles;

uniform vec4 rnd;
uniform vec4 rainbow;
uniform vec2 viewSize;
uniform vec2 pixelSize;
uniform vec2 aspect;
uniform vec2 mouse;
uniform vec2 mouseV;
uniform float fps;
uniform float time;
uniform float frame;
uniform vec4 scale;
uniform vec4 color1;

uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;

uniform float fov;
uniform vec3 camera;
uniform float pointSizeMin;
uniform float pointSizeMax;

varying vec4 col;
varying float alphaFactor;
			
void main() {
	vec4 pos = texture2D(sampler_particles, uv);
	pos.xyz *= scale.xyz;

	float distance = length(camera-(modelViewMatrix * pos).xyz);
	gl_PointSize = scale.w*fov/distance*viewSize.y/2048.;
	
	alphaFactor = 1.;
	if(gl_PointSize < 1.){
		alphaFactor = max(gl_PointSize, 1./16.);
	}

	col = color1;

	pos.w = 1.;
	gl_Position = projectionMatrix  * modelViewMatrix * pos;
}
	</script>

	<script type="x-shader/x-fragment" id="shader-particle-renderer-fs"> 
varying vec4 col;
varying float alphaFactor;

void main() {
	gl_FragColor = col;
	gl_FragColor.a *= alphaFactor;
}
	</script>

	<script type="text/javascript">
		function getShader(gl, id) {
			var shaderScript = document.getElementById(id);
			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					str += k.textContent;
				k = k.nextSibling;
			}

			var fsIncScript = document.getElementById("shader-fs-inc");
			var incStr = "";
			k = fsIncScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					incStr += k.textContent;
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				str = incStr + str;
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex")
				shader = gl.createShader(gl.VERTEX_SHADER);
			else
				return null;
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
			if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
				alert("error compiling shader '" + id + "'\n\n" + gl.getShaderInfoLog(shader));
			return shader;
		}

		var gl;
		var ext;

		var prog_copy;
		var prog_advance;
		var prog_composite;
		var prog_blur_horizontal;
		var prog_blur_vertical;

		var prog_render_particles;

		var FBO_main;
		var FBO_main2;

		var FBO_noise;
		var FBO_blur;
		var FBO_blur2;
		var FBO_blur3;
		var FBO_blur4;
		var FBO_blur5;
		var FBO_blur6;

		var FBO_particles;

		var FBO_helper;
		var FBO_helper2;
		var FBO_helper3;
		var FBO_helper4;
		var FBO_helper5;
		var FBO_helper6;

		var texture_main_l; // main, linear
		var texture_main_n; // main, nearest (accurate uv access on the same buffer)
		var texture_main2_l; // main double buffer, linear
		var texture_main2_n; // main double buffer, nearest (accurate uv access on the same buffer)
		var texture_helper; // needed for multi-pass shader programs (2-pass Gaussian blur)
		var texture_helper2; // (1/4 resolution )
		var texture_helper3; // (1/16 resolution )
		var texture_helper4; // (1/256 resolution )
		var texture_helper5;
		var texture_helper6;

		var texture_blur; // full resolution blur result
		var texture_blur2; // double blur
		var texture_blur3; // quad blur
		var texture_blur4; // use low resolutions wisely ;)
		var texture_blur5;
		var texture_blur6;

		var texture_noise_n; // nearest
		var texture_noise_l; // linear interpolation

		// particle position buffer in a texture
		var texture_particles;

		var particlesWidth = 512;
		var particlesHeight = 512;

		var particleCount = 64 * 64 * 64;// can also be set to lower than particlesWidth * particlesHeight

		// main animation loop vars

		var sizeX = 1024; // texture size (must be powers of two, must also be greater than the particles texture *?*)
		var sizeY = 512;

		var viewX = sizeX; // viewport size (ideally exactly the texture size)
		var viewY = sizeY;

		var halted = false;
		var delay = 1 / 60;
		var it = 1; // main loop buffer toggle
		var frame = 0; // frame counter (to be resetted every 1000ms)
		var framecount = 0; // not resetted
		var fps;
		var time;
		var timer;
		var starttime = new Date().getTime();

		var mouseX = 0.5;
		var mouseY = 0.5;
		var oldMouseX = 0;
		var oldMouseY = 0;
		var mouseDx = 0;
		var mouseDy = 0;

		var particleBuffer;

		//Threejs setup
		var camera, scene, group, controls;
		var gui, scopeParams;

		var ScopeParams = function () {
			this.Fps = 30; // reset every second anyway

			this.scaleX = 1;
			this.scaleY = 1;
			this.scaleZ = 1;
			this.pointSize = 1;

			this.distance = 4.0;
			this.fov = 16.;
			this.pointSizeMin = 0;
			this.pointSizeMax = 12;

			this.color1 = [255, 128, 42];
			
			this.alpha = 0.33;
			
		}

		function onViewportChanged(){
			viewX = window.innerWidth;
			viewY = window.innerHeight;
			c.width = viewX;
			c.height = viewY;

			var angle = 75;
			var aspect = viewX / viewY;
			var near = .1;
			var far = 10000;

			camera = new THREE.PerspectiveCamera(angle, aspect, near, far);
			scene = new THREE.Scene();
			group = new THREE.Object3D();
			scene.add(camera);
			scene.add(group);
			camera.lookAt(group);

			// Camera projection matrix 

			updateMatrices();

			controls = new THREE.TrackballControlsWithPropagation(camera);

			group.position.set(0, 0, 0);

			camera.position.set(0, 0, scopeParams.distance);

			camera.fov = scopeParams.fov;
			camera.projectionMatrix = new THREE.Matrix4().makePerspective(camera.fov, window.innerWidth / window.innerHeight, camera.near, camera.far);

			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;

			controls.dynamicDampingFactor = 0.15;
		}

		function load() {
			scopeParams = new ScopeParams();
			gui = new dat.GUI();
			gui.add(scopeParams, 'Fps');
	
			var scaleFolder = gui.addFolder('Scale (x10)');
			scaleFolder.add(scopeParams, 'scaleX', 0, 10).listen();
			scaleFolder.add(scopeParams, 'scaleY', 0, 10).listen();
			scaleFolder.add(scopeParams, 'scaleZ', 0, 10).listen();
			scaleFolder.add(scopeParams, 'pointSize', 0, 10).listen();

			scopeParams.resetScale = function(){
				scopeParams.scaleX = 1;
				scopeParams.scaleY = 1;
				scopeParams.scaleZ = 1;
				scopeParams.pointSize = 1;
			}
			scaleFolder.add(scopeParams, 'resetScale');
	
			var colorFolder = gui.addFolder('Color')
			colorFolder.addColor(scopeParams, 'color1');
			colorFolder.add(scopeParams, 'alpha', 0, 1);
			
			var projectionFolder = gui.addFolder('Projection');
			projectionFolder.add(scopeParams, 'fov', 12, 120).listen();
			projectionFolder.add(scopeParams, 'distance', 1, 10).listen();

			clearInterval(timer);
			var c = document.getElementById("c");
			try {
				gl = c.getContext("experimental-webgl", { depth: false });
			} catch (e) {
			}
			if (!gl) {
				alert("Meh! Y u no support experimental WebGL !?!");
				return;
			}

			["OES_texture_float", "OES_standard_derivatives", "OES_texture_float_linear"].forEach(function (name) {
				console.log("check " + name);
				try {
					ext = gl.getExtension(name);
				} catch (e) {
					alert(e);
				}
				if (!ext) {
					alert("Meh! Y u no support " + name + " !?!\n(Chrome 29 or Firefox 24 will do fine)");
					return;
				}
				ext = false;
			});

			if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0) {
				alert("Meh! Y u no support vertex shader textures !?!");
				return;
			}

			document.getElementById('fileselector').addEventListener('change', handleFileSelect, false);

			document.onmousemove = function (event) {
				mouseX = event.clientX / viewX;
				mouseY = 1 - event.clientY / viewY;
			}

			document.addEventListener("orientationchange", window.onresize = onViewportChanged);

			onViewportChanged();
			
			prog_copy = createAndLinkProgram("shader-fs-copy");
			prog_advance = createAndLinkProgram("shader-fs-advance");
			prog_composite = createAndLinkProgram("shader-fs-composite");
			prog_blur_horizontal = createAndLinkProgram("shader-fs-blur-horizontal");
			prog_blur_vertical = createAndLinkProgram("shader-fs-blur-vertical");

			gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());

			var aPosLoc = gl.getAttribLocation(prog_advance, "aPos");
			var aTexLoc = gl.getAttribLocation(prog_advance, "aTexCoord");

			gl.enableVertexAttribArray(aPosLoc);
			gl.enableVertexAttribArray(aTexLoc);

			var verticesAndTexCoords = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1, // one square of a quad!
			0, 0, 1, 0, 0, 1, 1, 1] // hello texture, you be full
			);

			gl.bufferData(gl.ARRAY_BUFFER, verticesAndTexCoords, gl.STATIC_DRAW);
			gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 8, 0);
			gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 8, 32);

			var noiseFullBuffer = new ArrayBuffer(sizeX * sizeY * 16);
			noiseFullBuffer.float32 = new Float32Array(noiseFullBuffer);
			for(var i = 0; i < sizeX * sizeY; i++){
				noiseFullBuffer.float32[i * 4 + 3] = 1;
			}
			var noiseFullBuffer = new ArrayBuffer(sizeX * sizeY * 16);
			noiseFullBuffer.float32 = new Float32Array(noiseFullBuffer);
			for(var i = 0; i < sizeX * sizeY * 4; i++){
				noiseFullBuffer.float32[i] = Math.random();
			}
			var d = 1 / 512;
			var locationCoordsBuffer = new ArrayBuffer(512 * 512 * 16);
			locationCoordsBuffer.float32 = new Float32Array(locationCoordsBuffer);
			for(var i = 0; i < 512 ; i++){
				for(var j = 0; j < 512 ; j++){
					locationCoordsBuffer.float32[(i * 512 + j)*2 + 0] = d / 2 + j * d;
					locationCoordsBuffer.float32[(i * 512 + j)*2 + 1] = d / 2 + i * d;
				}
			}
			var attributesBuffer = new ArrayBuffer(512 * 512 * 16);
			attributesBuffer.float32 = new Float32Array(attributesBuffer);

			// initial "block" of 64x64x64 points
			var w = 1.;
			var h = 1.;
			var d = 1.;
			for (var k = 0; k < 64; k++) {
				for (var j = 0; j < 64; j++) {
					for (var i = 0; i < 64; i++) {
						var index = k * 64 * 64 + j * 64 + i;
						attributesBuffer.float32[index * 4 + 0] = i / 64. * w - 0.5 * w;
						attributesBuffer.float32[index * 4 + 1] = j / 64. * h - 0.5 * h;
						attributesBuffer.float32[index * 4 + 2] = k / 64. * d - 0.5 * d;
						attributesBuffer.float32[index * 4 + 3] = 1;
					}
				}
			}

			FBO_main = gl.createFramebuffer();
			FBO_main2 = gl.createFramebuffer();
			texture_main_n = createAndBindTexture(noiseFullBuffer.float32, 1, FBO_main, gl.NEAREST);
			texture_main2_n = createAndBindTexture(noiseFullBuffer.float32, 1, FBO_main2, gl.NEAREST);
			texture_main_l = createAndBindTexture(noiseFullBuffer.float32, 1, FBO_main, gl.LINEAR);
			texture_main2_l = createAndBindTexture(noiseFullBuffer.float32, 1, FBO_main2, gl.LINEAR);

			FBO_helper = gl.createFramebuffer();
			FBO_helper2 = gl.createFramebuffer();
			FBO_helper3 = gl.createFramebuffer();
			FBO_helper4 = gl.createFramebuffer();
			FBO_helper5 = gl.createFramebuffer();
			FBO_helper6 = gl.createFramebuffer();
			texture_helper = createAndBindTexture(null, 1, FBO_helper, gl.NEAREST); // helper buffers for the two-pass Gaussian blur
			// calculation basically
			texture_helper2 = createAndBindTexture(null, 2, FBO_helper2, gl.NEAREST);
			texture_helper3 = createAndBindTexture(null, 4, FBO_helper3, gl.NEAREST);
			texture_helper4 = createAndBindTexture(null, 8, FBO_helper4, gl.NEAREST);
			texture_helper5 = createAndBindTexture(null, 16, FBO_helper5, gl.NEAREST);
			texture_helper6 = createAndBindTexture(null, 32, FBO_helper6, gl.NEAREST);

			FBO_blur = gl.createFramebuffer();
			FBO_blur2 = gl.createFramebuffer();
			FBO_blur3 = gl.createFramebuffer();
			FBO_blur4 = gl.createFramebuffer();
			FBO_blur5 = gl.createFramebuffer();
			FBO_blur6 = gl.createFramebuffer();
			texture_blur = createAndBindTexture(null, 1, FBO_blur, gl.LINEAR);
			texture_blur2 = createAndBindTexture(null, 2, FBO_blur2, gl.LINEAR);
			texture_blur3 = createAndBindTexture(null, 4, FBO_blur3, gl.LINEAR);
			texture_blur4 = createAndBindTexture(null, 8, FBO_blur4, gl.LINEAR);
			texture_blur5 = createAndBindTexture(null, 16, FBO_blur5, gl.LINEAR);
			texture_blur6 = createAndBindTexture(null, 32, FBO_blur6, gl.LINEAR);

			FBO_noise = gl.createFramebuffer();
			texture_noise_n = createAndBindTexture(noiseFullBuffer.float32, 1, FBO_noise, gl.NEAREST);
			texture_noise_l = createAndBindTexture(noiseFullBuffer.float32, 1, FBO_noise, gl.LINEAR);

			FBO_particles = gl.createFramebuffer();
			texture_particles = createAndBindParticleTexture(attributesBuffer.float32, FBO_particles);

			// lesson learned: the (frame) buffer location that we pass to the vertex shader has to be bound to the program before linking!

			var aParticleLoc = 2; // no getAttributeLoc
			prog_render_particles = createAndLinkParticleRenderer(aParticleLoc);

			gl.useProgram(prog_render_particles);
			gl.uniform1i(gl.getUniformLocation(prog_render_particles, "sampler_particles"), 0);

			gl.enableVertexAttribArray(aParticleLoc);
			particleBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, locationCoordsBuffer.float32, gl.STATIC_DRAW);
			gl.vertexAttribPointer(aParticleLoc, 2, gl.FLOAT, false, 8, 0);

			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur);
			gl.activeTexture(gl.TEXTURE3);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur2);
			gl.activeTexture(gl.TEXTURE4);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur3);
			gl.activeTexture(gl.TEXTURE5);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur4);
			gl.activeTexture(gl.TEXTURE6);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur5);
			gl.activeTexture(gl.TEXTURE7);
			gl.bindTexture(gl.TEXTURE_2D, texture_blur6);
			gl.activeTexture(gl.TEXTURE8);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_l);
			gl.activeTexture(gl.TEXTURE9);
			gl.bindTexture(gl.TEXTURE_2D, texture_noise_n);
			gl.activeTexture(gl.TEXTURE10);
			gl.bindTexture(gl.TEXTURE_2D, texture_particles); // to be swapped anyways

			calculateBlurTexture();

			timer = setInterval(fr, 1000);
			time = new Date().getTime() - starttime;

			gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
			gl.clearColor(0, 0, 0, 1);

			anim();
		}

		function updateMatrices() {
			scene.updateMatrixWorld();
			camera.matrixWorldInverse.getInverse(camera.matrixWorld);

			if (!camera._viewMatrixArray)
				camera._viewMatrixArray = new Float32Array(16);
			camera.matrixWorldInverse.flattenToArray(camera._viewMatrixArray);

			if (!camera._projectionMatrixArray)
				camera._projectionMatrixArray = new Float32Array(16);
			camera.projectionMatrix.flattenToArray(camera._projectionMatrixArray);

			if (!group.__webglInit) {
				group._modelViewMatrix = new THREE.Matrix4();
				group._objectMatrixArray = new Float32Array(16);
				group._modelViewMatrixArray = new Float32Array(16);
			}

			group.matrixWorld.flattenToArray(group._objectMatrixArray);
			group._modelViewMatrix.multiplyToArray(camera.matrixWorldInverse, group.matrixWorld, group._modelViewMatrixArray);
		}

		function createAndLinkProgram(fsId) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-vs"));
			gl.attachShader(program, getShader(gl, fsId));
			gl.linkProgram(program);
			return program;
		}

		function createAndLinkParticleRenderer(aParticleLoc) {
			var program = gl.createProgram();
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-vs"));
			gl.attachShader(program, getShader(gl, "shader-particle-renderer-fs"));
			gl.bindAttribLocation(program, aParticleLoc, "uv"); // can't use getAttribLocation later so we must bind before linking
			gl.linkProgram(program);
			return program;
		}

		function createAndBindTexture(glPixels, scale, fbo, filter) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sizeX / scale, sizeY / scale, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			checkFrameBuffer();
			return texture;
		}

		function createAndBindParticleTexture(glPixels, fbo) {
			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.FLOAT, glPixels);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			//gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
			checkFrameBuffer();
			return texture;
		}

		var newlocations = false;
		function onlocations() {
			newlocations = true;
		}

		function loadNewLocationTextures() {
			if (newlocations) {
				// assume only one file has been loaded and it's the last in the list of IDs
				// TODO: catch the exceptional case that you tried to reload a file and it hasn't been parsed again since it had not changed in byte length too
				var locations = files[fileIDs[fileIDs.length-1]].locations;
				gl.activeTexture(gl.TEXTURE10);

				gl.bindTexture(gl.TEXTURE_2D, texture_particles);
				gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_particles);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, particlesWidth, particlesHeight, 0, gl.RGBA, gl.FLOAT, locations.stridedFloat32Arrays[1]);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_particles, 0);
			}
		}

		function checkFrameBuffer() {
			var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			if (status != gl.FRAMEBUFFER_COMPLETE) {
				console.log("Framebuffer, y u not completed yet!?");
				for (var i in gl) {
					if (typeof (gl[i]) == "number" && gl[i] == status) {
						console.log("-> " + i);
					}
				}
			}
		}

		function setUniforms(program) {
			gl.uniform4f(gl.getUniformLocation(program, "rnd"), Math.random(), Math.random(), Math.random(), Math.random());
			gl.uniform4f(gl.getUniformLocation(program, "rainbow"), rainbowR, rainbowG, rainbowB, 1);
			gl.uniform2f(gl.getUniformLocation(program, "texSize"), sizeX, sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "viewSize"), viewX, viewY);
			gl.uniform2f(gl.getUniformLocation(program, "pixelSize"), 1. / sizeX, 1. / sizeY);
			gl.uniform2f(gl.getUniformLocation(program, "aspect"), Math.max(1, viewX / viewY), Math.max(1, viewY / viewX));
			gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
			gl.uniform2f(gl.getUniformLocation(program, "mouseV"), mouseDx, mouseDy);
			gl.uniform1f(gl.getUniformLocation(program, "fps"), fps);
			gl.uniform1f(gl.getUniformLocation(program, "time"), time);
			gl.uniform1f(gl.getUniformLocation(program, "frame"), framecount);

			gl.uniform4f(gl.getUniformLocation(program, "scale"), scopeParams.scaleX, scopeParams.scaleY, scopeParams.scaleZ, scopeParams.pointSize);
			if(typeof(scopeParams.color1) == "string"){
				var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(scopeParams.color1);
				scopeParams.color1 = [
					parseInt(result[1], 16),
					parseInt(result[2], 16),
					parseInt(result[3], 16)
				];
			}
			gl.uniform4f(gl.getUniformLocation(program, "color1"), scopeParams.color1[0]/255, scopeParams.color1[1]/255, scopeParams.color1[2]/255, scopeParams.alpha);
			gl.uniform1f(gl.getUniformLocation(program, "fov"), 1./Math.tan(scopeParams.fov/180*Math.PI));
			gl.uniform3f(gl.getUniformLocation(program, "camera"), 0, 0, scopeParams.distance);
			
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev"), 0);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_prev_n"), 1);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur"), 2);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur2"), 3);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur3"), 4);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur4"), 5);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur5"), 6);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_blur6"), 7);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise"), 8);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_noise_n"), 9);
			gl.uniform1i(gl.getUniformLocation(program, "sampler_particles"), 10);
		}

		function calculateBlurTextures() {
			var texture_source = (it < 0) ? texture_main2_l : texture_main_l;
			calculateBlurTexture(texture_source, texture_blur, FBO_blur, texture_helper, FBO_helper, 1);
			calculateBlurTexture(texture_blur, texture_blur2, FBO_blur2, texture_helper2, FBO_helper2, 2);
			calculateBlurTexture(texture_blur2, texture_blur3, FBO_blur3, texture_helper3, FBO_helper3, 4);
			calculateBlurTexture(texture_blur3, texture_blur4, FBO_blur4, texture_helper4, FBO_helper4, 8);
			calculateBlurTexture(texture_blur4, texture_blur5, FBO_blur5, texture_helper5, FBO_helper5, 16);
			calculateBlurTexture(texture_blur5, texture_blur6, FBO_blur6, texture_helper6, FBO_helper6, 32);
		}

		function calculateBlurTexture(sourceTex, targetTex, targetFBO, helperTex, helperFBO, scale) {
			// copy source
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_copy);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, sourceTex);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.flush();

			// blur vertically
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_vertical);
			gl.uniform2f(gl.getUniformLocation(prog_blur_vertical, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, targetTex);
			gl.bindFramebuffer(gl.FRAMEBUFFER, helperFBO);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.flush();

			// blur horizontally
			gl.viewport(0, 0, sizeX / scale, sizeY / scale);
			gl.useProgram(prog_blur_horizontal);
			gl.uniform2f(gl.getUniformLocation(prog_blur_horizontal, "pixelSize"), scale / sizeX, scale / sizeY);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, helperTex);
			gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.flush();
		}

		// main texture feedback warp
		function advance() {

			// texture warp step

			gl.viewport(0, 0, sizeX, sizeY);
			gl.useProgram(prog_advance);
			setUniforms(prog_advance);
			if (it > 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l); // interpolated input
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n); // "nearest" input
				gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_main2); // write to buffer
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l); // interpolated
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n); // "nearest"
				gl.bindFramebuffer(gl.FRAMEBUFFER, FBO_main); // write to buffer
			}
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.flush();

			it = -it;
		}

		function composite() {
			gl.viewport(0, 0, viewX, viewY);
			gl.useProgram(prog_composite);
			setUniforms(prog_composite);
			gl.activeTexture(gl.TEXTURE10);
			gl.bindTexture(gl.TEXTURE_2D, texture_particles);
			if (it < 0) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main_n);
			} else {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_l);
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, texture_main2_n);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.flush();
			frames++;
		}

		var rainbowR, rainbowG, rainbowB, w = Math.PI * 2 / 3;

		function anim() {
			time = new Date().getTime() - starttime;

			var t = time / 150;

			rainbowR = 0.5 + 0.5 * Math.sin(t);
			rainbowG = 0.5 + 0.5 * Math.sin(t + w);
			rainbowB = 0.5 + 0.5 * Math.sin(t - w);

			if (oldMouseX != 0 && oldMouseY != 0) {
				mouseDx = (mouseX - oldMouseX) * viewX;
				mouseDy = (mouseY - oldMouseY) * viewY;
			}

			if(newlocations){
				loadNewLocationTextures();
				newlocations = false;
			}

			if (!halted)
				advance();

			var renderTexture = false;

			calculateBlurTextures();

			if (renderTexture) {
				composite();
			} else {
				controls.update();
				updateMatrices();
				renderParticles();
			}

			setTimeout("requestAnimationFrame(anim)", delay);

			oldMouseX = mouseX;
			oldMouseY = mouseY;

			frame++;
			framecount++;
		}

		function renderParticles() {
			gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);

			gl.viewport(0, 0, viewX, viewY);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null); // draw directly on screen
			gl.useProgram(prog_render_particles);
			setUniforms(prog_render_particles);

			gl.uniformMatrix4fv(gl.getUniformLocation(prog_render_particles, "projectionMatrix"), false, camera._projectionMatrixArray);
			gl.uniformMatrix4fv(gl.getUniformLocation(prog_render_particles, "modelViewMatrix"), false, camera._viewMatrixArray);

			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			gl.enable(gl.BLEND);

			gl.activeTexture(gl.TEXTURE10);
			for(var i = 0; i < fileIDs.length; i++){
				var file = files[fileIDs[i]];
				var lastChunk = file.locations.numChunks - 1;
				for(var j = 0; j < file.locations.numChunks; j++){
					var locationTexture = file.locations.textures[j];
					gl.bindTexture(gl.TEXTURE_2D, locationTexture);
					var pointCount = file.locations.bufferLength;
					if(j == lastChunk){
						pointCount = file.locations.numLines - file.locations.bufferLength * lastChunk
					}
					gl.drawArrays(gl.POINTS, 0, pointCount);
				}
			}


			gl.disable(gl.BLEND);
			gl.flush();
		}

		function updateMatrices() {
			scene.updateMatrixWorld();
			camera.matrixWorldInverse.getInverse(camera.matrixWorld);

			if (!camera._viewMatrixArray)
				camera._viewMatrixArray = new Float32Array(16);
			camera.matrixWorldInverse.flattenToArray(camera._viewMatrixArray);

			if (!camera._projectionMatrixArray)
				camera._projectionMatrixArray = new Float32Array(16);
			camera.projectionMatrix.flattenToArray(camera._projectionMatrixArray);

			if (!group.__webglInit) {
				group._modelViewMatrix = new THREE.Matrix4();
				group._objectMatrixArray = new Float32Array(16);
				group._modelViewMatrixArray = new Float32Array(16);
			}

			group.matrixWorld.flattenToArray(group._objectMatrixArray);
			group._modelViewMatrix.multiplyToArray(camera.matrixWorldInverse, group.matrixWorld, group._modelViewMatrixArray);
		}
		var locations;
		function onlocationinfo(locations) {
			if (locations) {
				locations.float32Arrays = [];
				for (title = 0; title < locations.titles.length; title++) {
					locations.float32Arrays[title] = new Float32Array(locations.arrayBuffers[title]);
				}
				locations.stridedFloat32Arrays = [];
				locations.textures = [];
				for (var chunk = 0; chunk < locations.numChunks; chunk++) {
					locations.stridedFloat32Arrays[chunk] = new Float32Array(locations.stridedArrayBuffers[chunk]);
					locations.textures[chunk] = createAndBindParticleTexture(locations.stridedFloat32Arrays[chunk], FBO_particles);
				}
				file.locations = locations;
				addFile(file);
				if (onlocations) {
					onlocations();
				}
				console.log("locations uploaded to WebGL textures:");
				console.log(locations);
			} else {
				console.log("something went wrong");
			}
		}

		function fr() { // updates every second
			scopeParams.Fps = frame;
			gui.__controllers[0].updateDisplay();
			document.getElementById("fps").textContent = frame;

			frame = 0; // reset the frame counter
		}

		window.addEventListener('DOMMouseScroll', mousewheel, false);
		window.addEventListener('mousewheel', mousewheel, false);

		function mousewheel(event) {
			event.preventDefault();
			event.stopPropagation();

			var fovMAX = 130;
			var fovMIN = 1;

			camera.fov -= event.wheelDeltaY * 0.0033;
			camera.fov = Math.max(Math.min(camera.fov, fovMAX), fovMIN);
			camera.projectionMatrix = new THREE.Matrix4().makePerspective(camera.fov, window.innerWidth / window.innerHeight, camera.near, camera.far);

			scopeParams.fov = camera.fov;
		}

		var hidden = false;
		function hide() {
			hidden = !hidden;
			document.getElementById("desc").style.setProperty('visibility', hidden ? 'hidden' : 'visible');
		}
	</script>
	<style type="text/css">
		body {
			background-color: #000000;
			color: #FFFFFF;
			font-family: Lucida Console;
		}

		#c {
			position: absolute;
			top: 0;
			left: 0;
			z-index: -1;
			// border: solid 1px #FFFFFF;
		}

		a {
			color: #D0D0D0;
			font-weight: bold;
		}

		#desc {
			background-color: rgba(0, 0, 0, 0 .);
			width: 768px;
		}
	</style>
</head>
<body onload="load()" ondblclick="hide()">
	<script type="text/javascript" src="js/Three.js"></script>
	<script type="text/javascript" src="js/TrackballcontrolsWithPropagation.js"></script>
	<script type="text/javascript" src="js/dat.gui.min.js"></script>
	<div id="desc">
		Fps: <span id="fps"></span>		<br />
		GET 3D-STORM.xls <br />
		PUT
		<input type="file" id="fileselector" /><br />
		<span id="fileinfo"></span>
	</div>
	<canvas id="c"></canvas>
</body>
</html>
